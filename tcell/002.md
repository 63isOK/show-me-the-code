# 资源申请流水

主要包含了以下几个操作,下面一一分析:

- 设置备用编码
- 创建screen对象
- 初始化screen对象
- 设置screen的风格,并清空屏幕内容

## 设置备用编码

tcell的目的是在cli中进行字符图形的ui设计.
此处的cli可以是真实的控制台(linux的tty),
也可以是模拟终端(putty),
也可以是windows上的cmd等等.
cli对字符的编码格式的支持程度各不相同,
tcell库支持了很多编码格式,但不一定满足所有的cli需求,
如果tcell不支持cli指定的编码格式,那tcell也要提供一个备选方案,
就是主动告诉tcell备用编码格式,
这样的好处是保证cli要求的编码格式不被tcell支持时,
tcell还可以用一个备用的编码格式来处理.

回到demo源码,备用编码指定的是ascii编码.

- 这个备用编码存储在encodingFallback变量中
- 这个变量是一个包级别,不导出的变量,默认值是fail
- 这个变量只在GetEncoding中使用
  - 这个GetEncoding的功能就是返回一个tcell支持的编码格式
  - 具体实现是先找预设的编码列表encodings
    - 这个encodings也是一个包级别变量
    - 这个列表变量会在init中做一些初始化
  - 找不到,就使用备用编码(box中的备用编码指定为ascii编码)

备用编码的事已经理清楚了,再看下GetEncoding的调用关系

单单tcell这个包里面,调用这个GetEncoding()的有两处:

- tScreen.Init()
- simscreen.Init()

一个是终端,一个是模拟终端.
不管咋样,都是一个screen对象初始化时调用的.
看下调用时的逻辑:通过GetEncoding得到编码信息,
然后初始化和screen绑定的字符编解码器.

字符编解码器的部分后面单独讲到.

## 创建screen对象

回到box的源码,tcell.NewScreen()就是用于创建screen对象.

这里有几点需要说明一下:

- NewScreen()返回的是一个接口类型Screen
- NewScreen会依次尝试创建适合控制台和终端类型的Screen
- 目前还没有支持适合控制台Screen的实现

NewScreen()最后会调用到NewTerminfoScreen():

- 第一步:找匹配的终端信息
  - 首先会通过环境变量TERM来做一次筛选
    - 没有这个环境变量,就不会构建Screen变量
    - 真实的终端中,TERM环境变量的值是linux
    - 模拟的终端中,TERM环境变量的值是xterm
    - 不过上面都是在我的机器上测出的结果,其他还有好多种
    - 检查环境变量中是否指定支持真彩色
    - 最后返回适合当前环境的终端信息(如果没找到,就不会创建Screen)
  - 未找到终端信息时的一种例外
    - eg:TERM环境变量对应的xterm是tcell并未支持的
    - 可通过动态加载的方式(tcell的一种处理)来尝试确定终端信息
    - 如果尝试过程中找到了终端信息,也算第一步是成功的
- 第二步,构造Screen对象
  - 通过终端信息来构造一个tScreen对象
  - 申请一些引用变量资源
  - 为tScreen对象添加按键信息
  - 添加unicode到备选编码的映射(只有终端不支持unicode才使用这些映射)
  - 处理一些不可见字符的映射
