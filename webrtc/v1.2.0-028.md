# sfu

## readme

示例的功能：sfu

准备工作：

编译好示例程序

整个流程：

里面有两个角色：推流者和拉流者，都是通过浏览器进行推流和拉流,可以有多个拉流者

## 粗略分析

只分析示例程序，不深入webrtc api中

1. 首先注册一种编码格式 vp8/90000
2. 创建配置和连接
3. 初始化一个信道数组和一个读写锁
4. 设置OnTrack回调
5. 对offer进行解码，调用设置远端sdp的接口(这个接口表示整个连接的开始)
6. 生成answer，供浏览器使用,到此，推流者的逻辑就全了
7. for循环处理可能出现的拉流者

拉流者逻辑：

1. 将页面上offer对应的base64字符串进行解码处理
2. 利用配置创建一个连接
3. 设置一些采样track(后面会重点分析)
4. 设置远端sdp，生成answer

相对于从浏览器接收摄像头画面demo而言，这个项目需要分析：

- 推流者对应的OnTrack回调
- 拉流者采样track的处理

## 推流者OnTrack分析

    builder := samplebuilder.New(256, &codecs.VP8Packet{})
    for {
      outboundSamplesLock.RLock()
      builder.Push(<-track.Packets)
      for s := builder.Pop(); s != nil; s = builder.Pop() {
        for _, outChan := range outboundSamples {
          outChan <- *s
        }
      }
      outboundSamplesLock.RUnlock()
    }

samplebuilder，可以理解为一个专门的缓冲对象，
她主要用来接收rtp包，读的时候，返回的是media.RTCSample，
这里一个样本可能是多个rtp组合而成的，samplebuilder还负责了样本组合的功能。
她的实现是一个队列，所以提供了pop/push功能。

上面New中，定义了样本队列有效缓冲长度是256,样本可以按vp8来解码，
队列总长度是65535,是不是有点印象，对了rtp序号是16位，正好是65535，
这块具体可以看下之前单独包的分析过程，都有分析到。

接下来看下后面的for循环

收一个包就往样本队列中添加一个，然后遍历所有的接收者，将包转给她们。
