# RTCDataChannel

## 目录

<!-- vim-markdown-toc GFM -->

- [idl分析](#idl分析)
- [使用RTCDataChannel建立连接的两种方式](#使用rtcdatachannel建立连接的两种方式)
- [底层数据传输](#底层数据传输)
- [可靠性](#可靠性)
- [其他说明](#其他说明)
- [创建一个data channel](#创建一个data-channel)
- [宣布一个data channel打开了](#宣布一个data-channel打开了)
- [宣布创建一个data channel实例](#宣布创建一个data-channel实例)

<!-- vim-markdown-toc -->

## idl分析

    interface RTCDataChannel : EventTarget {
      readonly attribute USVString label;
      readonly attribute boolean ordered;
      readonly attribute unsigned short? maxPacketLifeTime;
      readonly attribute unsigned short? maxRetransmits;
      readonly attribute USVString protocol;
      readonly attribute boolean negotiated;
      readonly attribute unsigned short? id;
      readonly attribute RTCDataChannelState readyState;
      readonly attribute unsigned long bufferedAmount;
      [EnforceRange] attribute unsigned long bufferedAmountLowThreshold;
      attribute EventHandler onopen;
      attribute EventHandler onbufferedamountlow;
      attribute EventHandler onerror;
      attribute EventHandler onclosing;
      attribute EventHandler onclose;
      void close();
      attribute EventHandler onmessage;
      attribute DOMString binaryType;
      void send(USVString data);
      void send(Blob data);
      void send(ArrayBuffer data);
      void send(ArrayBufferView data);
    };

在分析功能之前，先简单看下idl。

继承于事件。除了属性，只剩下两类方法，关闭close和send发送。
属性又分常规属性和回调处理。

RTCDataChannel接口表示的是两端之间的双向数据通道。
RTCDataChannel对象是通过RTCPeerConnection的工厂方法创建的，后面会重点分析方法

RTCDataChannel这块主要遵循了两个rfc：
[如何利用sctp来传输非媒体数据](https://tools.ietf.org/html/draft-ietf-rtcweb-data-channel-13),
[如何建立连接](https://tools.ietf.org/html/draft-ietf-rtcweb-data-protocol-09)

## 使用RTCDataChannel建立连接的两种方式

第一种，简单的在一端创建一个RTCDataChannel对象，
入参RTCDataChannelInit.negotiated这字段要么不设，要么设置为默认值false。
这种情况下，这端会宣布有新的数据带内数据通道，并在对端触发RTCDataChannelEvent事件。
带内，in-band，表示网络控制信息和业务数据使用同一个通道进行传输。

第二种，应用程序协商RTCDataChannel。
这种情况下，创建一个RTCDataChannel对象，
入参RTCDataChannelInit.negotiated这字段设置为true。
还必须通过带外(out-of-band)信令通知对端，保证对端也创建对应的RTCDataChannel对象，
入参RTCDataChannelInit.negotiated这字段设置为true,而且字段id和本端保持一致。
带外，所以要通过额外的系统来传数据(这也正常，毕竟是用应用程序来协商)。
这种情况下，两端的RTCDataChannel对象是独立创建。

第二种情况可以创建非对称的属性，也可以通过指定匹配id来用声明式创建通道。

## 底层数据传输

每个RTCDataChannel都有一个相关的底层数据传输(这个才是真正传数据的)。
在使用RTCSctpTransport的sctp数据通道中，底层数据传输就是sctp stream对。
底层数据传输的传输属性都是channel创建时配置的，这些属性包括分发设置和可靠性设置。

## 可靠性

sctp结合了tcp和udp的特点，底层还是使用udp，所以在可靠性方面也做了些文章。

tcp的可靠性来至重发，RTCDataChannel提供了多种配合重发的机制(也称可靠性模型)。
一个不可靠的RTCDataChannel可配置最大重发次数maxReTransmits，
也可以配置重发重试最大时长maxPacketLifeTime。这两类属性不能同时指定，
同时指定会导致错误。如果这两类属性都不指定，表示是一个可靠channel，
此时会重发，直到成功。

## 其他说明

RTCDataChannel对象，要么在连接对象的createDataChannel方法中创建，
要么被对应的RTCDataChannelEvent事件触发创建。她们的最初状态都是connecting。
当底层传输准备妥当之后，要宣布RTCDataChannel打开了(后面就可以传消息了)。

## 创建一个data channel

- channel = new RTCDataChannel
- 内部状态ReadyState初始化为connecting
- 内部状态BufferedAmount初始化为0
- 还有以下内部状态
  - DataChannelLabel
  - Ordered
  - MaxPacketLifeTime
  - MaxRetransmits
  - DataChannelProtocol
  - Negotiated
  - DataChanelId
- 返回channel

## 宣布一个data channel打开了

- 如果connection.IsClosed 是true，退出
- channel = 宣布打开的RTCDataChannel
- 如果channel.ReadyState是closing/closed,退出
- channel.ReadyState = open
- 触发一个open事件

## 宣布创建一个data channel实例

如果对端peer创建了一个RTCDataChannel，negotiated没有设置，或设置为fasle，
这个符合RTCDataChanel创建的第一个场景，带内传输信令。
此时本端agent按照逻辑是没有创建RTCDataChannel的，queue a task创建一个：

- connection = 连接对象
- 如果connection.IsClosed是tue，退出
- [创建一个data channel](#创建一个data-channel)，放在变量channel中
- configuration = 对端为了建立连接而传过来的信息
- 用configuration中的值来初始化channel的内部状态，都有这些
  - DataChannelLabel
  - Ordered
  - MaxPacketLifeTime
  - MaxRetransmits
  - DataChannelProtocol
  - DataChannelId
- channel.Negotiated = false
- channel.ReadyState = open,此时不触发open事件(此时重要的是通过通道发送数据，而不是触发open事件)
- 在连接对象触发datachannel事件，参数是channel
- [宣布一个data channel打开了](#宣布一个data-channel打开了)
