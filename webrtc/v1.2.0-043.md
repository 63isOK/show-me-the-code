# RTCPeerConnection中的RTP Media API

[spec](https://www.w3.org/TR/webrtc/#rtcpeerconnection-interface-extensions)

从idl中看，主要添加了以下几个方法：

- getSenders 获取RTCRtpSender列表
- getReceviers 获取RTCRtpReceiver列表
- getTransceivers 获取RTCRtpTransceiver列表
- addTrack 添加一个轨道
- removeTrack 移出一个轨道
- addTransceiver 添加一个传输通道

还添加了一个属性：

- ontrack，是一个事件处理，可理解为函数回调

## 详细接口说明

ontrack回调，对应的接口是RTCTrackEvent，
触发条件是：RTCRtpReceiver协商好了一个新的媒体流，
并且接收者的track轨道已经加到相关的远端MediaStream流中了。

具体的接口RTCTrackEvent可看后面的5.7

getSenders方法

RTCPeerConnection对象中，未停止的RTCRtpTransceiver中，
rtp发送者对应的对象是RTCRtpSender，这个方法就是将所有未停止通道中的发送者获取到

整个方法执行的过程被称为CollectSenders算法(收集发送者算法)，具体算法如下：

- 执行CollectTransceivers算法，得到未停止的通道
- 创建一个新的空sender数组
- 遍历未停止通道，将sender填充到数组中
- 返回数组

其中CollectTransceivers算法就是getTransceivers方法的执行逻辑。

getReceivers方法

获取连接对象中未停止通道中，表示rtp接收者的RTCRtpReceiver列表。
执行逻辑如下：

- 调用CollectTransceivers算法
- 创建一个新的空receiver数组
- 遍历未停止通道，将receiver填充到数组中
- 返回数组

getTransceivers方法

获取连接对象中的通道列表，也就是RTCRtpTransceiver数组

整个执行逻辑被称为CollectTransceivers算法，具体如下：

- 创建要给新的空的通道列表，将连接对象的通道复制一份
- 返回通道列表

addTrack方法

    RTCRtpSender addTrack(MediaStreamTrack track, MediaStream... streams);

webidl定义如上。

功能是给连接添加一个新的轨道track。轨道是在容器stream流中的。
addTrack的流程如下：

- connection = RTCPeerConnection对象
- track = MediaStreamTrack对象(第一个入参)
- kind = track.kind
- 入参是可变参，streams = 后续的MediaStream参数
- 如果connection.IsClosed是true，抛出一个InvalidStateError错误
- senders = getSenders(),如果track已经和某个RTCRtpSender绑定，抛出InvalidAccessError错误
- 如果RTCRtpSender重用了，走以下步骤
  - 安装jsep第5节，重用会导致sdp的重新协商，sendrecv/sendonly/msid要加到流中
  - 只有RTCRtpSender满足以下全部条件时，这个sender才可以进行重用，否则返回null
    - sender的轨道为null，也就是说这个sender还没有绑定轨道
    - kind和sender的kind一致
    - RTCRtpTransceiver的stopping槽是false
    - 这个sender还未用于发送数据，更确切一点，就是RTCRtpTransceiver.CurrentDirection还未指定值
- 如果sender不为null，执行以下步骤
  - sender.SendrTrack = track
  - sender.AssociatedMediaStreamIds = 空集合
  - 对于streams中的每个stream，将stream.id添加上上面那个集合中
  - 找到sender归属的transceiver
  - 如果transceiver.Direction == recvonly， 将方向改为sendrecv
  - 如果transceiver.Direction == inactive， 将方向改为sendonly
- 如果sender为null，执行以下步骤
  - 用track/kind构造一个RTCRtpSender，并赋值给sender变量
  - 用kind构造一个RTCRtpReceiver，并赋值给receiver变量
  - 用sender/receiver/值为sendrecv的RTCRtpTransceiverDirection构造一个RTCRtpTransceiver
  - 将构造的transceiver添加到连接对象的通道集合中
- 有时应用程序可能无法访问轨道的内容，这是因为跨域问题
  - addTrack支持这些场景，遇到这些场景可能用静音/黑屏来代替轨道内容
  - 关于这点，后续的spec可能随时会改变
- 更新连接的negotiation-needed标记
- 返回sender

removeTrack方法

停止sender的媒体发送。停止之后调用getSenders依然可以获取到这个被停止的sender，
这么做的原因是为了将来调用createOffer将sdp标记为recvonly/inactive(jsep5.2规定)

如果有一端调用这个方法来停止某个轨道，
那么对应的远端会在Mediastream中移出相应的轨道(通过track事件关联的)，
如果MediaStreamTrack未静音，那么mute事件会被触发

和removeTrack有相同功能的操作步骤是：

- 设置RTCRtpTransceiver.direction
- 媒体发送者调用RTCRtpSender.replaceTrack(null)

这两种方式的细微区别是：removeTrack是同步的;replaceTrack是异步的。

    void removeTrack(RTCRtpSender sender);

removeTrack的逻辑如下：

- sender = 入参
- connection = 连接对象
- connection.IsClosed 为true，抛出一个InvalidStateError错误
- 如果这个sender不属于这个connectin，抛出一个InvalidAccessError错误
- senders = getSenders()
- 如果sender不再senders中，表明传输通道已停止或sdp进行了rollback，退出后续步骤
- sender.SenderTrack为null，退出后续步骤
- 找到sender相关的传输通道transceiver
- 如果transceiver.Direction == sendrecv， 将方向改为recvonly
- 如果transceiver.Direction == sendonly， 将方向改为inactive
- 更新连接的negotiation-needed标记
