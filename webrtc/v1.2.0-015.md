# rtcp

rtp协议家族的另一位是rtcp

rtcp是控制协议，用于qos质量保证和同步媒体流，占用的资源非常少。

## rfc中的rtcp

rtp传的是数据包，rtcp传的是控制包，她们两种包的传输机制是一样的，
控制包会定期向会话中所有参与者发送。

rtcp主要有4个功能：

- 最主要的功能：反馈数据分发的质量
  - 这个反馈可能会用于编码的自适应
- rtcp会带有一个传输级的标识
  - 这个标识可以标记rtp的源，那可以通过这个标记来识别参与者
  - 为啥不用rtp的ssrc，因为rtp程序重启后ssrc就会变
- 控制rtcp传输间隔
  - 当参与者多时，可保证rtcp包不超过流量的5%
- 可选，最小控制信息，eg：可标记出哪个参与者掉线了

### rtcp报文格式

rfc3550定义了5种不同的rtcp控制包：

- sr，send report，发送者的统计分析
- rr，receiver report，接收者的接收分析，如果源超过31个，就配合sr一起使用
- sdes，source description items,源描述包，对应rtcp第二个功能
- bye，结束参数包，表示结束
- app，应用程序指定函数

rfc4585 rfc6051分别定义了其他几种rtcp包，下面也会一一讲到

每个rtcp包的开头都是固定的，接下来是不同类型的包，这些包可能是可变长度，
不过最后都会填充到4字节的倍数。
为了让rtcp可以堆叠，rtcp包开头的固定部分和可变部分的长度需要在协议中指定出来，
堆叠的好处是，发送一个复合包，其实里面包含了多个rtcp包。
这里面不会显示指明rtcp包的个数。
复合包中的每个rtcp都可以被单独处理，且对顺序是没有要求的，但有以下3点约束：

- 统计分析包(sr/rr),带宽约束会影响最大分辨率，所以统计分析包发的越频繁越好。
  - 定期发送的复合包中，至少要包含一个统计分析包
- 新的接收者加入是，要尽可能接收源的标识
  - 定期发送的复合包中，至少要包含一个sdes包
- 为了提高rtcp数据包验证通过的可能性
  - 需要限制复合包中rtcp包类型的数量

复合rtcp包的格式应该如下：

- 加密首部，可选，如果复合包要加密，就会有这个，32位
- sr或rr，必选，即使没有数据包，也要发送这个，即使复合包里是bye，也要发这个
- 附加的rr列表，可选，接收反馈，超过31个要皮和sr一起
- sdes,必选
- bye或app，可选，还可能出现多次

一个rtp相关的rtcp，在固定间隔发送rtcp复合包时，一次只发一个rtcp包，
这是为了正确控制rtcp流量，这是一般情况，也有特例(rfc3550 section9.1)。
如果复合包太大，一个间隔也最多发mtu。

    if encrypted: random 32-bit integer
    |
    |[--------- packet --------][---------- packet ----------][-packet-]
    |
    |                receiver            chunk        chunk
    V                reports           item  item   item  item
    --------------------------------------------------------------------
    R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
    --------------------------------------------------------------------
    |                                                                  |
    |<-----------------------  compound packet ----------------------->|
    |<--------------------------  UDP packet ------------------------->|

之后就对着rfc定义的格式来分析源码

## 目录分析

通过粗略分析，所有的文件都描述了一小部分数据结构，然后实现了和字符串之间的转换，
最后在packet.go中，体现在Packet数据结构中

一个Packet表示一个rtcp控制包，这种层级分明的树形结构，就用类图来表示

[类图](https://www.draw.io/?mode=github#H63isOK%2Fconference_graph%2Fmaster%2Fpion-webrtc%2Fpion%2Fwebrtc%40v1.2.0)

分析类图时，发现v1.2.0的rtcp包除了实现了rfc3550,还实现了rfc4585

v1.2.0版本的rtcp并没有发现堆叠解包的情况，wrishark抓7牛的包，
发现rtcp包很少会堆叠。至于pion对rtcp的实现，就从源码上看

## 源码分析 - Reader

reader.go中暴露了一个Reader结构体，这个源文件还包含了构造函数和一个方法。

这个Reader对象是读一段缓冲，通过方法ReadPacket将里面的报文解析出来，
对于不同类型的rtcp包，就使用不同的数据结构来进行反序列化。

整个ReadPacket的过程分以下几个步骤：

- 读包头
- 更具包头指定的长度，读剩下的packet

## 源码分析 - rtcp 包头

header.go 这是按rfc中将各种rtcp固定头部提取出来，因为她们的格式都超不多。

下面是几种rtcp包的头信息

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=SR=200   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=RR=201   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |  PT=SDES=202  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |   PT=BYE=203  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P| subtype |   PT=APP=204  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|   FMT   | PT=RTPFB/PSFB |             length            |

    // rfc中对固定头部的定义
    /*
    * RTCP common header word
    */
    typedef struct {
      unsigned int version:2;   /* protocol version */
      unsigned int p:1;         /* padding flag */
      unsigned int count:5;     /* varies by packet type */
      unsigned int pt:8;        /* RTCP packet type */
      u_int16 length;           /* pkt len in words, w/o this word */
    } rtcp_common_t;

固定头部是4个字节 = 2 + 1 + 5 + 8 + 16 = 32bit

具体分析(rfc的描述)：

- V 指明rtp版本，rfc3550固定是2
- P 复合包中，如果rtcp包的长度不是8bit的倍数，就需要填充位。非复合包为0
- RC 指明这个rtcp包中包含几个"接收报告块"
- SC 表明这个rtcp包中ssrc/csrc块的个数
- subtype 是APP依赖的数据
- FMT 指明反馈消息的类型
- PT rtcp包payload的类型，也就是rtcp包的类型，从200-206
- length rtcp包的长度(包含了固定头，填充位，和payload)

rfc对这个length的定义非常有意思，这也是之前对源码感到疑惑的地方，
在rfc中，这个length说的是rtcp包的长度，单位是4字节，而且是减1之后的数值，
如果说length=5,那rtcp的具体长度是len = (length+1) * 4, 结果就是多少字节

    packetLen := (header.Length + 1) * 4
    // 这是pion源码中的写法，一一对应

现在我们再将Reader.ReadPacket()炒一次现饭：

- 读头4个字节，反序列化为固定头
- 从头中计算出这个rtcp包的长度，继续读
- 读正确后，将头和整个rtcp的[]byte返回

现在回到本节的主题，Header

    type Header struct {
      Padding bool
      Count uint8
      Type PacketType
      Length uint16
    }

这个结构用于存储固定头的有效信息(版本是2,所以这里都没有存)，至于rtcp类型，
在源码中还定义了200-206，和rfc是一一对应的，接下来和Header就是序列化方法。

Header.Marshal():

- 就是一个4字节的组装

从源码中发现Count不能超过31,因为只有5位，也不能表达太多，
也和rfc对rr不能超过31正好遥相呼应,所以说所有的限制都有其具体原因。

Header.Unmarshal():

- 长度检查，然后使用位移操作取出感兴趣的字段

## Packet

packaet.go 对外暴露Packet数据结构和一个函数(将字节流解析为Packet)

从这个将字符串解析为Packet的函数中，可以看出这个v1.2.0版本的rtcp对rfc的支持程度，
sr/rr/sdes/bye/rtpfb/psfb。并没有app。

对于多种不同类型的rtcp包，Packet被设计成一个接口类型，
这个接口类型的接口包含了读取固定头/取ssrc列表/和字符串之间的序列化和反序列化

接下来就看看各种rtcp类型对这个接口的实现

## sr

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    RC   |   PT=SR=200   |             length            |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         SSRC of sender                        |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    sender |              NTP timestamp, most significant word             |
    info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |             NTP timestamp, least significant word             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         RTP timestamp                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                     sender's packet count                     |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      sender's octet count                     |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_1 (SSRC of first source)                 |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      1    | fraction lost |       cumulative number of packets lost       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           extended highest sequence number received           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      interarrival jitter                      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         last SR (LSR)                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                   delay since last SR (DLSR)                  |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_2 (SSRC of second source)                |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      2    :                               ...                             :
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
           |                  profile-specific extensions                  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

sr/rr 是一种报告，rtp接收者可利用这个反馈接收质量，接收者反馈rr，发送者反馈sr。
sr和rr的区别还有什么(除了rtcp类型)，sr比rr多一个20字节，这20字节会附加一些
发送者的信息。在发送间隔内，就发送sr，不在就发送rr。
sr/rr里可能包含0个或多个接收报告块，每一个接收报告块对应着rtp接收者从上次报告
到现在，每路ssrc接收的情况。报告中不再具体分ssrc中csrc的细化。
报告中都是一些统计信息，最多31个(因为在固定头中，数量只有5位来表示)，
在一个间隔内，附加的rr包应该堆叠在sr/rr后面

上面是rfc对sr/rr的一些附加说明，现在我们先分析sr的格式，再对比代码。

sr的结构分3块：

- 8字节
  - 4字节的固定头部
  - 4字节发送者的ssrc
- 20字节的发送者信息
  - 8字节的ntp时间戳
  - 4字节的rtp时间戳
  - 4字节，总发送rtp包数(从开始到这个sr开始生成)
  - 4字节，总rtp payload总字节数(不含rtp头和填充位)
- (24 x n)字节，一个接收报告块24字节，可能有0个或多个
  - 接收块的数量取决于从上个报告开始，接收到了多少个ssrc
  - 一个接收报告块有如下内容
    - 4字节发送者的ssrc
    - 1字节的丢包率，从上个sr/rr开始，rtp的丢包率,如何计算：除以256就行
    - 3字节的累计丢包数，可为负(？，有重复包时可为负)
    - 4字节的最大序列号，rtp序列号是16位，用低16位表示，高16位表示置0次数
    - 4字节的间隔抖动，rtp数据包间隔时间变动的一个统计预估，用时间戳单位表示
    - 4字节的上个sr时间戳，取自64位ntp时间戳中的32位
    - 4字节的sr时间延时，从上个sr到发送本次接收报告的差，单位1/65535秒

回到sender_report.go源码

SenderReport结构完全按字节还原了rfc的定义,包括接收报告块都是如此

接收报告块用ReceptionReport结构来表示,她的序列化/反序列化也比较简单

SenderReport的序列化和反序列化都比较简单，这个Header()比较有意思，
固定头信息是通过已有信息生成的，并没有持久化，序列化时就是这么用的。
DestinationSSRC()这个是将接收报告块中所有ssrc提取出来。

那sr包就分析完了，序列化/反序列化，再加上所有字段都是暴露了，
业务逻辑就看调用方如何使用了。

## rr

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    RC   |   PT=RR=201   |             length            |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                     SSRC of packet sender                     |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_1 (SSRC of first source)                 |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      1    | fraction lost |       cumulative number of packets lost       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           extended highest sequence number received           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      interarrival jitter                      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         last SR (LSR)                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                   delay since last SR (DLSR)                  |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_2 (SSRC of second source)                |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      2    :                               ...                             :
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
           |                  profile-specific extensions                  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

rr包和sr包很类似，少了发送者的相关信息

rr包暴露的结构是ReceiverReport，看这个rr才发现sr/rr最后有一个扩展信息，
给应用程序使用的，v1.2.0的sr并未关系这个值，但rr关心了，如果这个值不满4的倍数，
会进行填充。

rr还暴露一个打印方法，可打印所有ssrc的丢包信息

## sdes

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    SC   |  PT=SDES=202  |             length            |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    chunk  |                          SSRC/CSRC_1                          |
      1    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                           SDES items                          |
           |                              ...                              |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    chunk  |                          SSRC/CSRC_2                          |
      2    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                           SDES items                          |
           |                              ...                              |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+

sdes是一个3层结构，除了固定的4字节头，还可能包括0个或多个chunk块，
每个块由ssrc/csrc和sdes元素组成，每个块的长度都是4字节的倍数，
每个sdes元素都是由1字节的类型 + 1字节的文本长度 + 文本 组成。
文本最长不超过255字节。元素是连续的，并不会先单独填充到4字节的边界，也是，
要填充也是在最后才填充。每个chunk块最后，至少会有一个空的单字节，
第一个空的单字节表示元素列表的结束，后面的可能就是为了填充到4字节边界而存在的。

rtp发送端会发送sdes类型的rtcp包，如果这个rtp流是混合流(eg:又有音频又有视频)，
要么是通过一个sdes来发送(一个chunk对应一个csrc)，要么通过多个sdes来发送。
后者适用于超过31个ssrc/csrc。

分析完了格式，回顾一下sdes，这是用来描述源的一种rtcp包。

现在来看一下源码中是如何表示这种结构的。

SourceDescriptionItem表示一个sdes元素

    type SourceDescriptionItem struct {
      Type SDESType
      Text string
    }

1字节的类型 + 1字节的长度 + 文本， 是元素的格式。
SDESType是uint8,1字节，长度和文本内容用Text表示

SourceDescriptionChunk表示一个chunk

    type SourceDescriptionChunk struct {
      Source uint32
      Items  []SourceDescriptionItem
    }

一个ssrc + 元素列表，就是一个chunk

chunk列表叫SourceDescription，也就是对外暴露的sdes类型的rtcp包

## bye

           0                   1                   2                   3
           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |V=2|P|    SC   |   PT=BYE=203  |             length            |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          |                           SSRC/CSRC                           |
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
          :                              ...                              :
          +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    (opt) |     length    |               reason for leaving            ...
          +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

bye包表示一个或多个源不再活跃。

如果一个混流器接收到一个bye包，在不改变ssrc/csrc的情况下转发这个bye包，
如果混流器自己要结束了，会发一个bye包，里面会列出所有的csrc，而不是自己的ssrc。

    type Goodbye struct {
      Sources []uint32
      Reason string
    }

源码中的接口实现也满足Packet

## nack 通用丢包

此时fmt=1 pt=rtpfb

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|   FMT   |       PT      |          length               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  SSRC of packet sender                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  SSRC of media source                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :            Feedback Control Information (FCI)                 :
    :                                                               :

在介绍其他前，先介绍以下rtp扩展 rfc4585中定义的另外几种rtcp包

反馈包feedback message。上面的格式是一个通用的反馈包，头信息我们前面已经分析了，
现在继续深入分析。

FMT，feedback message type，反馈消息类型，rfc规定了3种：传输层/负载层/应用层。
v1.2.0的pion没有关心应用层。

PT，rtcp类型，205表示传输层的反馈消息类型，206表示负载层的反馈消息类型。

FCI，反馈控制信息，不同类型的反馈，差别主要在这块

通用nack，是传输层反馈消息，根据rfc，fmt为1, pt为rtpfb

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |            PID                |             BLP               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

上面是丢包重传nack的fci，pid是2字节，表示rtp的哪个序号包丢了，
blp，一个丢包掩码，指示从pid开始，接下来16个包的丢失情况，
如果丢了，对应掩码位就会置1,可利用rtcp的丢包信息来实现丢包重传。

结合上面两个结构，看下源码的实现：

    type TransportLayerNack struct {
      SenderSSRC uint32
      MediaSSRC uint32
      Nacks []NackPair
    }

    type NackPair struct {
      PacketID uint16
      LostPackets PacketBitmap
    }

PacketBitmap 就是uint16,NackPair对应着fci，接下来看看对Packet的实现。

从结构中可看出，nack信息对应一个发送者的一个源。下面看看TransportLayerNack的实现。

TransportLayerNack对Packet的实现，和其他rtcp包类似，都遵循了rfc。
fci中，NackPair.PacketList()提供了获取丢包列表的接口

## rrr

rapid resynchronisation request, 短期重新同步请求，rfc6051。

rfc6051是对rfc3550的扩展，类似rfc4585对3550的扩展一样，不过6051的主题是rtp同步，
短期内的同步来提供质量。

6051说明：

大多数rtp会话都是立即同步的，mcu(多点会议单元的视频切换)/ssm(大型特定源多播)
在同步时会导致延时，在某些场景下，这些延时是不可接受的，eg：分层或多编码器场景。
6051就是在这种场景下，使用了减少每个rtp会话同步延时的方法。6051做了3步：

1. 更新rtcp的时间规则，减少ssm会话初始同步的延时
2. 新增一种rtcp反馈包，来让mcu切换视频支持短期请求重新同步
3. 为了让后加入的参与者短期同步，要定义一种新的rtp扩展头(是不同时钟的解码可以统一时间戳)

回到我们的rtcp，v1.2.0中实现了6051的[rrr](https://tools.ietf.org/html/rfc6051#section-3.2)

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|   FMT   | PT=RTPFB=205  |          length               |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  SSRC of packet sender                        |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                  SSRC of media source                         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    :            Feedback Control Information (FCI)                 :
    :                                                               :

这个rrr的fmt是5,术语叫rtcp-sr-req,其他的和tln包基本没啥区别，而且这个fci为空。

rrr包一般由rtp接收者发送，当无法将接收到的媒体流进行同步时，就发rrr给发送者，
发送者接着会以最快速度发送一个sr包过来，sr包含了发送者的时间信息。
当然rrr发送之后，可能还是没有sr到来，下个间隔时，也会发送rrr。

回到pion的v1.2.0 rtcp包，repid_resynchronization_request.go

    type RapidResynchronizationRequest struct {
      SenderSSRC uint32
      MediaSSRC uint32
    }

因为没有fci，所以rrr的结构非常简单

## 未解析的rtcp包

raw_packet.go定义了一个RawPacket，表示未处理的rtcp包,用作默认处理

## pli

picture loss indication, 一种负载级的反馈消息，rfc4585中定义的。

pli的pt是psfb，fmt是1，格式遵循通用的反馈格式。

pli是图像丢失指示，整个图像帧丢失后报告，还有一个相对的sli(帧内部分块丢失后报告)，
这两种都适用于支持"帧间预测编码"特性的编码器。
发送pli/sli之后，发送端会有一个补偿帧发过来。

pli是没有fci的，这类通知类都不需要带fci信息。

对Packet的实现也非常简单
