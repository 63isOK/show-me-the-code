# rtcp

rtp协议家族的另一位是rtcp

rtcp是控制协议，用于qos质量保证和同步媒体流，占用的资源非常少。

## rfc中的rtcp

rtp传的是数据包，rtcp传的是控制包，她们两种包的传输机制是一样的，
控制包会定期向会话中所有参与者发送。

rtcp主要有4个功能：

- 最主要的功能：反馈数据分发的质量
  - 这个反馈可能会用于编码的自适应
- rtcp会带有一个传输级的标识
  - 这个标识可以标记rtp的源，那可以通过这个标记来识别参与者
  - 为啥不用rtp的ssrc，因为rtp程序重启后ssrc就会变
- 控制rtcp传输间隔
  - 当参与者多时，可保证rtcp包不超过流量的5%
- 可选，最小控制信息，eg：可标记出哪个参与者掉线了

### rtcp报文格式

rfc3550定义了5种不同的rtcp控制包：

- sr，send report，发送者的统计分析
- rr，receiver report，接收者的接收分析，如果源超过31个，就配合sr一起使用
- sdes，source description items,源描述包，对应rtcp第二个功能
- bye，结束参数包，表示结束
- app，应用程序指定函数

每个rtcp包的开头都是固定的，接下来是不同类型的包，这些包可能是可变长度，
不过最后都会填充到4字节的倍数。
为了让rtcp可以堆叠，rtcp包开头的固定部分和可变部分的长度需要在协议中指定出来，
堆叠的好处是，发送一个复合包，其实里面包含了多个rtcp包。
这里面不会显示指明rtcp包的个数。
复合包中的每个rtcp都可以被单独处理，且对顺序是没有要求的，但有以下3点约束：

- 统计分析包(sr/rr),带宽约束会影响最大分辨率，所以统计分析包发的越频繁越好。
  - 定期发送的复合包中，至少要包含一个统计分析包
- 新的接收者加入是，要尽可能接收源的标识
  - 定期发送的复合包中，至少要包含一个sdes包
- 为了提高rtcp数据包验证通过的可能性
  - 需要限制复合包中rtcp包类型的数量

复合rtcp包的格式应该如下：

- 加密首部，可选，如果复合包要加密，就会有这个，32位
- sr或rr，必选，即使没有数据包，也要发送这个，即使复合包里是bye，也要发这个
- 附加的rr列表，可选，接收反馈，超过31个要皮和sr一起
- sdes,必选
- bye或app，可选，还可能出现多次

一个rtp相关的rtcp，在固定间隔发送rtcp复合包时，一次只发一个rtcp包，
这是为了正确控制rtcp流量，这是一般情况，也有特例(rfc3550 section9.1)。
如果复合包太大，一个间隔也最多发mtu。

    if encrypted: random 32-bit integer
    |
    |[--------- packet --------][---------- packet ----------][-packet-]
    |
    |                receiver            chunk        chunk
    V                reports           item  item   item  item
    --------------------------------------------------------------------
    R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
    --------------------------------------------------------------------
    |                                                                  |
    |<-----------------------  compound packet ----------------------->|
    |<--------------------------  UDP packet ------------------------->|

之后就对着rfc定义的格式来分析源码

## 目录分析

通过粗略分析，所有的文件都描述了一小部分数据结构，然后实现了和字符串之间的转换，
最后在packet.go中，体现在Packet数据结构中

一个Packet表示一个rtcp控制包，这种层级分明的树形结构，就用类图来表示

[类图](https://www.draw.io/?mode=github#H63isOK%2Fconference_graph%2Fmaster%2Fpion-webrtc%2Fpion%2Fwebrtc%40v1.2.0)

分析类图时，发现v1.2.0的rtcp包除了实现了rfc3550,还实现了rfc4585

v1.2.0版本的rtcp并没有发现堆叠解包的情况，wrishark抓7牛的包，
发现rtcp包很少会堆叠。至于pion对rtcp的实现，就从源码上看

## 源码分析 - Reader

reader.go中暴露了一个Reader结构体，这个源文件还包含了构造函数和一个方法。

这个Reader对象是读一段缓冲，通过方法ReadPacket将里面的报文解析出来，
对于不同类型的rtcp包，就使用不同的数据结构来进行反序列化。

整个ReadPacket的过程分以下几个步骤：

- 读包头
- 更具包头指定的长度，读剩下的packet

## 源码分析 - rtcp 包头

header.go 这是按rfc中将各种rtcp固定头部提取出来，因为她们的格式都超不多。

下面是几种rtcp包的头信息

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=SR=200   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=RR=201   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |  PT=SDES=202  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |   PT=BYE=203  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P| subtype |   PT=APP=204  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|   FMT   | PT=RTPFB/PSFB |             length            |

    // rfc中对固定头部的定义
    /*
    * RTCP common header word
    */
    typedef struct {
      unsigned int version:2;   /* protocol version */
      unsigned int p:1;         /* padding flag */
      unsigned int count:5;     /* varies by packet type */
      unsigned int pt:8;        /* RTCP packet type */
      u_int16 length;           /* pkt len in words, w/o this word */
    } rtcp_common_t;

固定头部是4个字节 = 2 + 1 + 5 + 8 + 16 = 32bit

具体分析(rfc的描述)：

- V 指明rtp版本，rfc3550固定是2
- P 复合包中，如果rtcp包的长度不是8bit的倍数，就需要填充位。非复合包为0
- RC 指明这个rtcp包中包含几个"接收报告块"
- SC 表明这个rtcp包中ssrc/csrc块的个数
- subtype 是APP依赖的数据
- FMT 指明反馈消息的类型
- PT rtcp包payload的类型，也就是rtcp包的类型，从200-206
- length rtcp包的长度(包含了固定头，填充位，和payload)

rfc对这个length的定义非常有意思，这也是之前对源码感到疑惑的地方，
在rfc中，这个length说的是rtcp包的长度，单位是4字节，而且是减1之后的数值，
如果说length=5,那rtcp的具体长度是len = (length+1) * 4, 结果就是多少字节

    packetLen := (header.Length + 1) * 4
    // 这是pion源码中的写法，一一对应

现在我们再将Reader.ReadPacket()炒一次现饭：

- 读头4个字节，反序列化为固定头
- 从头中计算出这个rtcp包的长度，继续读
- 读正确后，将头和整个rtcp的[]byte返回

现在回到本节的主题，Header

    type Header struct {
      Padding bool
      Count uint8
      Type PacketType
      Length uint16
    }

这个结构用于存储固定头的有效信息(版本是2,所以这里都没有存)，至于rtcp类型，
在源码中还定义了200-206，和rfc是一一对应的，接下来和Header就是序列化方法。

Header.Marshal():

- 就是一个4字节的组装

从源码中发现Count不能超过31,因为只有5位，也不能表达太多，
也和rfc对rr不能超过31正好遥相呼应,所以说所有的限制都有其具体原因。

Header.Unmarshal():

- 长度检查，然后使用位移操作取出感兴趣的字段
