# rtcp

rtp协议家族的另一位是rtcp

rtcp是控制协议，用于qos质量保证和同步媒体流，占用的资源非常少。

## rfc中的rtcp

rtp传的是数据包，rtcp传的是控制包，她们两种包的传输机制是一样的，
控制包会定期向会话中所有参与者发送。

rtcp主要有4个功能：

- 最主要的功能：反馈数据分发的质量
  - 这个反馈可能会用于编码的自适应
- rtcp会带有一个传输级的标识
  - 这个标识可以标记rtp的源，那可以通过这个标记来识别参与者
  - 为啥不用rtp的ssrc，因为rtp程序重启后ssrc就会变
- 控制rtcp传输间隔
  - 当参与者多时，可保证rtcp包不超过流量的5%
- 可选，最小控制信息，eg：可标记出哪个参与者掉线了

### rtcp报文格式

rfc3550定义了5种不同的rtcp控制包：

- sr，send report，发送者的统计分析
- rr，receiver report，接收者的接收分析，如果源超过31个，就配合sr一起使用
- sdes，source description items,源描述包，对应rtcp第二个功能
- bye，结束参数包，表示结束
- app，应用程序指定函数

每个rtcp包的开头都是固定的，接下来是不同类型的包，这些包可能是可变长度，
不过最后都会填充到4字节的倍数。
为了让rtcp可以堆叠，rtcp包开头的固定部分和可变部分的长度需要在协议中指定出来，
堆叠的好处是，发送一个复合包，其实里面包含了多个rtcp包。
这里面不会显示指明rtcp包的个数。
复合包中的每个rtcp都可以被单独处理，且对顺序是没有要求的，但有以下3点约束：

- 统计分析包(sr/rr),带宽约束会影响最大分辨率，所以统计分析包发的越频繁越好。
  - 定期发送的复合包中，至少要包含一个统计分析包
- 新的接收者加入是，要尽可能接收源的标识
  - 定期发送的复合包中，至少要包含一个sdes包
- 为了提高rtcp数据包验证通过的可能性
  - 需要限制复合包中rtcp包类型的数量

复合rtcp包的格式应该如下：

- 加密首部，可选，如果复合包要加密，就会有这个，32位
- sr或rr，必选，即使没有数据包，也要发送这个，即使复合包里是bye，也要发这个
- 附加的rr列表，可选，接收反馈，超过31个要皮和sr一起
- sdes,必选
- bye或app，可选，还可能出现多次

一个rtp相关的rtcp，在固定间隔发送rtcp复合包时，一次只发一个rtcp包，
这是为了正确控制rtcp流量，这是一般情况，也有特例(rfc3550 section9.1)。
如果复合包太大，一个间隔也最多发mtu。

    if encrypted: random 32-bit integer
    |
    |[--------- packet --------][---------- packet ----------][-packet-]
    |
    |                receiver            chunk        chunk
    V                reports           item  item   item  item
    --------------------------------------------------------------------
    R[SR #sendinfo #site1#site2][SDES #CNAME PHONE #CNAME LOC][BYE##why]
    --------------------------------------------------------------------
    |                                                                  |
    |<-----------------------  compound packet ----------------------->|
    |<--------------------------  UDP packet ------------------------->|

之后就对着rfc定义的格式来分析源码

## 目录分析

通过粗略分析，所有的文件都描述了一小部分数据结构，然后实现了和字符串之间的转换，
最后在packet.go中，体现在Packet数据结构中

一个Packet表示一个rtcp控制包，这种层级分明的树形结构，就用类图来表示

[类图](https://www.draw.io/?mode=github#H63isOK%2Fconference_graph%2Fmaster%2Fpion-webrtc%2Fpion%2Fwebrtc%40v1.2.0)

分析类图时，发现v1.2.0的rtcp包除了实现了rfc3550,还实现了rfc4585

v1.2.0版本的rtcp并没有发现堆叠解包的情况，wrishark抓7牛的包，
发现rtcp包很少会堆叠。至于pion对rtcp的实现，就从源码上看

## 源码分析 - Reader

reader.go中暴露了一个Reader结构体，这个源文件还包含了构造函数和一个方法。

这个Reader对象是读一段缓冲，通过方法ReadPacket将里面的报文解析出来，
对于不同类型的rtcp包，就使用不同的数据结构来进行反序列化。

整个ReadPacket的过程分以下几个步骤：

- 读包头
- 更具包头指定的长度，读剩下的packet

## 源码分析 - rtcp 包头

header.go 这是按rfc中将各种rtcp固定头部提取出来，因为她们的格式都超不多。

下面是几种rtcp包的头信息

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=SR=200   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    RC   |   PT=RR=201   |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |  PT=SDES=202  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|    SC   |   PT=BYE=203  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P| subtype |   PT=APP=204  |             length            |

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|   FMT   | PT=RTPFB/PSFB |             length            |

    // rfc中对固定头部的定义
    /*
    * RTCP common header word
    */
    typedef struct {
      unsigned int version:2;   /* protocol version */
      unsigned int p:1;         /* padding flag */
      unsigned int count:5;     /* varies by packet type */
      unsigned int pt:8;        /* RTCP packet type */
      u_int16 length;           /* pkt len in words, w/o this word */
    } rtcp_common_t;

固定头部是4个字节 = 2 + 1 + 5 + 8 + 16 = 32bit

具体分析(rfc的描述)：

- V 指明rtp版本，rfc3550固定是2
- P 复合包中，如果rtcp包的长度不是8bit的倍数，就需要填充位。非复合包为0
- RC 指明这个rtcp包中包含几个"接收报告块"
- SC 表明这个rtcp包中ssrc/csrc块的个数
- subtype 是APP依赖的数据
- FMT 指明反馈消息的类型
- PT rtcp包payload的类型，也就是rtcp包的类型，从200-206
- length rtcp包的长度(包含了固定头，填充位，和payload)

rfc对这个length的定义非常有意思，这也是之前对源码感到疑惑的地方，
在rfc中，这个length说的是rtcp包的长度，单位是4字节，而且是减1之后的数值，
如果说length=5,那rtcp的具体长度是len = (length+1) * 4, 结果就是多少字节

    packetLen := (header.Length + 1) * 4
    // 这是pion源码中的写法，一一对应

现在我们再将Reader.ReadPacket()炒一次现饭：

- 读头4个字节，反序列化为固定头
- 从头中计算出这个rtcp包的长度，继续读
- 读正确后，将头和整个rtcp的[]byte返回

现在回到本节的主题，Header

    type Header struct {
      Padding bool
      Count uint8
      Type PacketType
      Length uint16
    }

这个结构用于存储固定头的有效信息(版本是2,所以这里都没有存)，至于rtcp类型，
在源码中还定义了200-206，和rfc是一一对应的，接下来和Header就是序列化方法。

Header.Marshal():

- 就是一个4字节的组装

从源码中发现Count不能超过31,因为只有5位，也不能表达太多，
也和rfc对rr不能超过31正好遥相呼应,所以说所有的限制都有其具体原因。

Header.Unmarshal():

- 长度检查，然后使用位移操作取出感兴趣的字段

## Packet

packaet.go 对外暴露Packet数据结构和一个函数(将字节流解析为Packet)

从这个将字符串解析为Packet的函数中，可以看出这个v1.2.0版本的rtcp对rfc的支持程度，
sr/rr/sdes/bye/rtpfb/psfb。并没有app。

对于多种不同类型的rtcp包，Packet被设计成一个接口类型，
这个接口类型的接口包含了读取固定头/取ssrc列表/和字符串之间的序列化和反序列化

接下来就看看各种rtcp类型对这个接口的实现

## sr

            0                   1                   2                   3
            0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    header |V=2|P|    RC   |   PT=SR=200   |             length            |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         SSRC of sender                        |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    sender |              NTP timestamp, most significant word             |
    info   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |             NTP timestamp, least significant word             |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         RTP timestamp                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                     sender's packet count                     |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      sender's octet count                     |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_1 (SSRC of first source)                 |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      1    | fraction lost |       cumulative number of packets lost       |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |           extended highest sequence number received           |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                      interarrival jitter                      |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                         last SR (LSR)                         |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
           |                   delay since last SR (DLSR)                  |
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    report |                 SSRC_2 (SSRC of second source)                |
    block  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      2    :                               ...                             :
           +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
           |                  profile-specific extensions                  |
           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

sr/rr 是一种报告，rtp接收者可利用这个反馈接收质量，接收者反馈rr，发送者反馈sr。
sr和rr的区别还有什么(除了rtcp类型)，sr比rr多一个20字节，这20字节会附加一些
发送者的信息。在发送间隔内，就发送sr，不在就发送rr。
sr/rr里可能包含0个或多个接收报告块，每一个接收报告块对应着rtp接收者从上次报告
到现在，每路ssrc接收的情况。报告中不再具体分ssrc中csrc的细化。
报告中都是一些统计信息，最多31个(因为在固定头中，数量只有5位来表示)，
在一个间隔内，附加的rr包应该堆叠在sr/rr后面

上面是rfc对sr/rr的一些附加说明，现在我们先分析sr的格式，再对比代码。

sr的结构分3块：

- 8字节
  - 4字节的固定头部
  - 4字节发送者的ssrc
- 20字节的发送者信息
  - 8字节的ntp时间戳
  - 4字节的rtp时间戳
  - 4字节，总发送rtp包数(从开始到这个sr开始生成)
  - 4字节，总rtp payload总字节数(不含rtp头和填充位)
- (24 x n)字节，一个接收报告块24字节，可能有0个或多个
  - 接收块的数量取决于从上个报告开始，接收到了多少个ssrc
  - 一个接收报告块有如下内容
    - 4字节发送者的ssrc
    - 1字节的丢包率，从上个sr/rr开始，rtp的丢包率,如何计算：除以256就行
    - 3字节的累计丢包数，可为负(？，有重复包时可为负)
    - 4字节的最大序列号，rtp序列号是16位，用低16位表示，高16位表示置0次数
    - 4字节的间隔抖动，rtp数据包间隔时间变动的一个统计预估，用时间戳单位表示
    - 4字节的上个sr时间戳，取自64位ntp时间戳中的32位
    - 4字节的sr时间延时，从上个sr到发送本次接收报告的差，单位1/65535秒

回到sender_report.go源码

SenderReport结构完全按字节还原了rfc的定义,包括接收报告块都是如此

接收报告块用ReceptionReport结构来表示,她的序列化/反序列化也比较简单

SenderReport的序列化和反序列化都比较简单，这个Header()比较有意思，
固定头信息是通过已有信息生成的，并没有持久化，序列化时就是这么用的。
DestinationSSRC()这个是将接收报告块中所有ssrc提取出来。

那sr包就分析完了，序列化/反序列化，再加上所有字段都是暴露了，
业务逻辑就看调用方如何使用了。
