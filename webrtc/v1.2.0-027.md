# 将摄像头画面录制下来

## readme

示例的功能：如何录制浏览器传过来的摄像头数据

准备工作：

编译好示例程序

整个流程：

打开页面，拷贝sdp，作为示例程序的入参，
将示例程序生成的sdp拷贝到页面第二个输入框，点击开始会话按钮

## 粗略分析

只分析示例程序，不深入webrtc api中

1. 首先注册两种编码格式 opus/4800/2 vp8/90000
2. 创建配置和连接
3. 设置OnTrack和OnICEConnectionStateChange回调
4. 对offer进行解码，调用设置远端sdp的接口(这个接口表示整个连接的开始)
5. 生成answer，供浏览器使用

最后动手的效果是：将摄像头数据录制成了一个ivf文件，这是vp8格式的视频文件。

浏览器js部分：创建offer，等answer设置后，执行开始会话，
其中会将连接状态打印出来

pion应用程序部分：

- 注册两个编码格式 opus/48000/2 vp8/90000
- 创建配置和连接
- 设定OnTrack/OnICEConnectionStateChange回调
- 对offer解码，调用设置远端sdp接口，开始进行连接
- 创建answer，返回给浏览器

整个媒体的传输和录制，都在其中，下面一步步分析

## 编码格式注册

    webrtc.RegisterCodec(
      webrtc.NewRTCRtpOpusCodec(webrtc.DefaultPayloadTypeOpus, 48000, 2))
    webrtc.RegisterCodec(
      webrtc.NewRTCRtpVP8Codec(webrtc.DefaultPayloadTypeVP8, 90000))

在分析完v1.2.0对媒体编码格式和媒体格式列表，
上面代码的意思就是使用默认媒体编码格式列表，添加opus和vp8两种格式

在构造连接时，New():

    func New(configuration RTCConfiguration) (*RTCPeerConnection, error) {

      pc := RTCPeerConnection{
        configuration: RTCConfiguration{
          IceServers:           []RTCIceServer{},
          IceTransportPolicy:   RTCIceTransportPolicyAll,
          BundlePolicy:         RTCBundlePolicyBalanced,
          RtcpMuxPolicy:        RTCRtcpMuxPolicyRequire,
          Certificates:         []RTCCertificate{},
          IceCandidatePoolSize: 0,
        },
        isClosed:          false,
        negotiationNeeded: false,
        lastOffer:         "",
        lastAnswer:        "",
        SignalingState:    RTCSignalingStateStable,
        // IceConnectionState: RTCIceConnectionStateNew, // FIXME SWAP-FOR-THIS
        IceConnectionState: ice.ConnectionStateNew, // FIXME REMOVE
        IceGatheringState:  RTCIceGatheringStateNew,
        ConnectionState:    RTCPeerConnectionStateNew,
        mediaEngine:        DefaultMediaEngine,
        sctpTransport:      newRTCSctpTransport(),
        dataChannels:       make(map[uint16]*RTCDataChannel),
      }

    }

在连接构造中，mediaEngine使用的就是默认的编码格式列表

## 配置和连接的构造

    config := webrtc.RTCConfiguration{
      IceServers: []webrtc.RTCIceServer{
        {
          URLs: []string{"stun:stun.l.google.com:19302"},
        },
      },
    }

    // Create a new RTCPeerConnection
    peerConnection, err := webrtc.New(config)
    util.Check(err)

配置对象，只指定了ice服务器地址

再来看下New构造函数，这个是构造一个p2p连接的agent

从源码中(rtcpeerconnection.go)中可以看出

New的流程如下：

- 构造一个空的连接对象，并赋一些默认值
  - ice候选收集策略：全部
  - bundle策略：平衡
  - rtcp mux 策略： 启用
  - 编码格式列表： 使用默认列表
- initConfiguration，拷贝配置中的数据到连接对象中
  - 如果指定了pid(peer id),拷贝
  - 如果配置有证书
    - 检查是否有过期，过期就退出函数
  - 如果配置中没有证书
    - 生成一个证书(具体过程没深入分析，等后面版本深入)
  - 如果配置指定bundle/rtcp mux/ice候选池大小/ice采集类型，拷贝
  - 如果有指定ice服务
    - 校验，并拷贝
- 从连接对象读取ice服务器地址
- 利用ice服务器地址外加两个回调来调用network.NewManager

最后构造network.NewManager的放在核心业务去分析

## network.NewManager的调用分析

分析完network.NewManager的内部实现后，是时候分析一下业务调用部分

    pc.networkManager = network.NewManager(urls, pc.generateChannel, pc.iceStateChange)

- 第一个参数是ice服务器列表
- 第二个参数是一个回调，用于给新媒体源ssrc创建一个TransportPair
- 第三个参数用于连接状态改变时的回调

接下来看看具体的实参是什么：

- 连接状态的变更
  - 最后是调用一个函数来通知的，如果有设置的话
    - OnICEConnectionStateChange用于设置这个函数
    - demo中就有设置这个函数(demo中仅仅是将这个函数打印出来而已)
- 给新的媒体源ssrc创建TransportPair
  - 调用的是generateChannel

generateChannel()

webrtc/rtcpeerconnection.go 处理手法和处理连接状态变更一毛一样，
通过OnTrack设置回调函数，在generateChannel中调用。

- 判断有没有通过OnTrack设置回调
- 通过rtp包中的ssrc和payloadType(这个对应sdp中的98 101等)查本地sdp是否支持
- 如果本地sdp支持相应的编码格式，再查连接对象中默认编码格式列表是否支持
- 创建两个长度15的信道，一个是传rtp的，一个是传rtcp的
- 将这些信息都封装进一个RTCTrack包中，作为之前设置的回调函数参数，调用回调函数

demo中的处理是调用OnTrack来设置回调，并从信道中取出rtp包,写入ivf中

到此为止，从网络连接读数据的整个流程我们都已经分析完了，当然，
仅仅是rtp包的流程。

此时连接对象和回调都已经设置好了，还等下面的开始连接和数据传输

## 设置回调

总共两个回调，我们都已经在上面分析完了，
需要补充一点，rtcp包的实现并不完善，所以每隔3秒发一个PLI包(rtcp的一种)，
让peer发一个关键帧过来。

## 处理offer

整个连接的开始(之前只是申请连接对象，并没有开始实际连接)

    offer := util.Decode(strOffer)

    // Set the remote SessionDescription
    err = peerConnection.SetRemoteDescription(offer)
    util.Check(err)

ps：由于每次运行demo都会出错，所以把浏览器上的offer用常量的方式加入到程序了。

util.Decode的处理是对offer字符串进行base64解码，并反序列化到sdp对象中，
核心业务的开始就是设置远端sdp，此处是SetRemoteDescription

之前也单独分析过webrtc spec和pion/webrtc@v1.2.0对这个函数的描述，
细节可以翻看之前的分析记录。

下面主要分析一下这个函数调用过程中，和其他模块的影响。
