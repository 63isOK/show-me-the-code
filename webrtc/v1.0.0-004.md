# rtp

real-time transport protocol 实时传输协议

设计之初，rtp准备用于多播协议，但最后在用在单播应用中。
rtp多用于流媒体系统，rtsp/sip/rtcp都和rtp有很紧密的联系。

rtp不负责提供按时发送机制，也不提供qos保证，
所以rtp rfc定义两个子协议：rtp和rtcp，

rtp协议负责实时传输数据，提供了如下信息：
时间戳(用于同步)，序列号(用于丢包和重整序)，负载格式(指明数据的编码格式)。

rtcp是控制协议，用于qos质量保证和同步媒体流，占用的资源非常少。

rtp使用偶数端口传数据，对应的rtcp使用下一个奇数端口号。

rtp注重的是传输的实时性，基于网络，会有一定的丢包;
tcp注重的是可靠性而不是实时性，所以rtp很少基于tcp，大部分都是udp。

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|X|  CC   |M|     PT      |       sequence number         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           timestamp                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           synchronization source (SSRC) identifier            |
    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    |            contributing source (CSRC) identifiers             |
    |                             ....                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

上面是一个rtp包头：

- V：rtp版本，目前是2, 2bit
- P：填充标识，1bit，如果p为1,表示rtp包后会有附加的填充字节，这些字节不属于payload
- X：扩展标识，1bit，如果x为1,表示rtp包头后会有一个扩展包头
- CC: csrc个数，4bit
- M：1bit，对于视频，标记一帧的结束;对于音频，标记会话的开始
- PT：payload 类型，7bit，说明prt报文中payload的类型，区分音视频
- 序列号：16bit，初始随机，之后每发送一个报文加1,音视频分别计数，
  可用于检查丢包，或网络抖动时用于重整序
- 时间戳：32bit，记录rtp报文第一个字节采样时的时刻，
  可用于计算网络延时和同步控制
- ssrc：32位，用于标识同步信源，随机唯一。同步源就是rtp包流的来源
- csrc：32位，贡献源列表，可能有0-15个，CC指明数量

这上面只列出了每个rtp的固定头部，扩展头部在下面(如果固定头部的X=1)：

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      defined by profile       |           length              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        header extension                       |
    |                             ....                              |

rtp rfc只定义了扩展报文的格式，具体里面的内容就没有具体指定。

## package.go

提供了rtp包的序列化(从一个Go数据结构生成字节流(rtp包))，和反序列化

反序列化Unmarshal()就是按rfc的标准，将固定头部和扩展头部一一解析，
最后将剩下的全部作为payload，(好像位考虑填充标识)

序列化，就是将Packet结构体中的数据重新转换成rtp包的字节流,
而且过程都是正好相反。

这里仅仅做了rtp包的序列化和反序列化，并不是rtc的全部，还有切片，整序等很多问题。

## seuencer.go

负责序列号的生成

从代码上有两种序列号生成器，一个是初始值随机，一个是初始值固定的，
这里通过暴露一个接口和两个函数来将实际负责逻辑的对象隐藏起来，这就是封装，
而且优雅，扩展性也好。

    type sequencer struct {
      sequenceNumber uint16
      rollOverCount  uint64
      mutex          sync.Mutex
    }

看看这个设计，sequenceNumber是16位，和rfc正好对应，所以就有了一个置0次数，
所以接口对外暴露了两个方法，一个是取下个序列号，另一个是取置0次数。

## packetizer.go

rtp打包的核心逻辑

第一个版本的确实比较简易，总共才57行

这里面有个packetizer的结构体，叫打包器，实现了打包接口(Packetize),
这个打包接口主要做的是将一段字节流打包成多个Packet包，
步骤很简单，第一步将一个长的字节流切成多个短的字节流，
第二步是将短的字节流反序列化到Packet包里

这里面，长字节流切成短字节流是一个接口，可在包调用方指定。

另外打包器打包时(调用Packetize()时)，M的指定直接按视频来处理，
直到把长字节流打包完之后，M才是true，对应报文的1。

这里面同样是使用接口 + 函数来隐藏了实际处理逻辑的对象(打包器)。

## 最后

总体来说，第一个版本确实很简易，在调用时，调用方需要提供切片逻辑，
在初始化还得指定序列号生成器的配置，在对应音视频时，需要自己维护序号生成器，
另外在过程中，特别是执行打包过程时，需要调用方自己维护时间戳。

简易带来的好处是实现简单，调用方可以有更多的定制;
坏处是这个rtp库和调用方的耦合度很高。

最后这个包只用了3个源文件就搞定了rtp包的打包问题，
一个负责序列化和反序列化;一个负责序列号生成器;一个负责对外暴露打包能力，
每一个的实现都非常简单，将业务逻辑丢到了调用方
