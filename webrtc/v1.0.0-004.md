# rtp

real-time transport protocol 实时传输协议

设计之初，rtp准备用于多播协议，但最后在用在单播应用中。
rtp多用于流媒体系统，rtsp/sip/rtcp都和rtp有很紧密的联系。

rtp不负责提供按时发送机制，也不提供qos保证，
所以rtp rfc定义两个子协议：rtp和rtcp，

rtp协议负责实时传输数据，提供了如下信息：
时间戳(用于同步)，序列号(用于丢包和重整序)，负载格式(指明数据的编码格式)。

rtcp是控制协议，用于qos质量保证和同步媒体流，占用的资源非常少。

rtp使用偶数端口传数据，对应的rtcp使用下一个奇数端口号。

rtp注重的是传输的实时性，基于网络，会有一定的丢包;
tcp注重的是可靠性而不是实时性，所以rtp很少基于tcp，大部分都是udp。

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |V=2|P|X|  CC   |M|     PT      |       sequence number         |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                           timestamp                           |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |           synchronization source (SSRC) identifier            |
    +=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    |            contributing source (CSRC) identifiers             |
    |                             ....                              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

上面是一个rtp包头：

- V：rtp版本，目前是2, 2bit
- P：填充标识，1bit，如果p为1,表示rtp包后会有附加的填充字节，这些字节不属于payload
- X：扩展标识，1bit，如果x为1,表示rtp包头后会有一个扩展包头
- CC: csrc个数，4bit
- M：1bit，对于视频，标记一帧的结束;对于音频，标记会话的开始
- PT：payload 类型，7bit，说明prt报文中payload的类型，区分音视频
- 序列号：16bit，初始随机，之后每发送一个报文加1,音视频分别计数，
可用于检查丢包，或网络抖动时用于重整序
- 时间戳：32bit，记录rtp报文第一个字节采样时的时刻，
可用于计算网络延时和同步控制
- ssrc：32位，用于标识同步信源，随机唯一。同步源就是rtp包流的来源
- csrc：32位，贡献源列表，可能有0-15个，CC指明数量

这上面只列出了每个rtp的固定头部，扩展头部在下面(如果固定头部的X=1)：

     0                   1                   2                   3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |      defined by profile       |           length              |
    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
    |                        header extension                       |
    |                             ....                              |

rtp rfc只定义了扩展报文的格式，具体里面的内容就没有具体指定。

## package.go

提供了rtp包的序列化(从一个Go数据结构生成字节流(rtp包))，和反序列化

反序列化Unmarshal()就是按rfc的标准，将固定头部和扩展头部一一解析，
最后将剩下的全部作为payload，(好像位考虑填充标识)

序列化，就是将Packet结构体中的数据重新转换成rtp包的字节流,
而且过程都是正好相反。

这里仅仅做了rtp包的序列化和反序列化，并不是rtc的全部，还有切片，整序等很多问题。
