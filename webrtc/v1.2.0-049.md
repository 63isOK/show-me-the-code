# RTCRtpTransceiver接口

这个接口是将RTCRtpSender和RTCRtpReceiver进行了组合，并共享了一个叫mid的标识。
按照jsep3.4.1的规定，RTCRtpTransceiver传输对象是和sdp的一个媒体级进行关联的，
媒体级中的mid就是上面说的mid标识，也就是sdp媒体级中的标签，
用于区分sdp中的不同媒体级，可用于关联RTCTransceiver对象。
不符合jsep的媒体级没有mid属性。mid一般在ice候选中体现，如果没有指定，
那mid取值就是媒体级的索引值。

mid非空就表示传输对象已经关联了，意思是已经应用了sdp中的值了。

传输对象的kind，也就是RTCRtpReceiver.MediaStreamTrack.kind，
换句话说，传输对象的kind就是接收的什么kind(video/audio)

    interface RTCRtpTransceiver {
      readonly attribute DOMString? mid;
      [SameObject] readonly attribute RTCRtpSender sender;
      [SameObject] readonly attribute RTCRtpReceiver receiver;
      attribute RTCRtpTransceiverDirection direction;
      readonly attribute RTCRtpTransceiverDirection? currentDirection;
      void stop();
      void setCodecPreferences(sequence<RTCRtpCodecCapability> codecs);
    };

除了上面提到的mid和发送者接收者，还有两个表示传输方向的属性，两个方法。

## 构造

构造参数：

- RTCRtpReceiver的receiver
- RTCRtpSender的sender
- RTCRtpTransceiverDirection的direction

构造逻辑如下：

- 构造一个空的RTCRtpTransceiver对象
- 内部状态Sender = sender
- 内部状态Receiver = receiver
- 内部状态Stopping = false
- 内部状态Stopped = false
- 内部状态Direction = direction
- 内部状态Receptive = false
- 内部状态CurrentDirection = null
- 内部状态FiredDirection = null
- 内部状态PreferredCodecs = 空列表
- 返回transceiver

构造传输对象的过程很简单，并没有构造相关的RTCDtlsTransport/RTCIceTransport，
这两个对象只有在设置sdp时才会构造。

## 属性

mid属性是jsep中定义的，在sdp协商中会起作用：标识媒体级。

sdp协商之前mid可能是null，sdp的回滚也可能让mid值为null

sender,用于发送rtp媒体，当然会和mid进行关联的。
在获取方面，返回Sender内部状态

receiver，用于接收rtp媒体，会和mid关联，在获取方面，返回Receiver内部状态。

direction，表明传输对象的首选方向，会被用在createOffer/createAnswer中。
在协商后会确定最终的方向，所以这个值的更新不是立马更新，
jsep定义了sendrecv/sendonly/recvonly/inactive。

direction在获取方面的逻辑如下：

- transceiver.Stopping是true，返回stopped
- 不是true，返回Direction内部状态

direction在设置方面的逻辑如下：

- connection = 传输对象关联的连接对象RTCPeerConnection
- 如果transceiver.Stopping是true，抛出InvalidStateError错误
- newDirection = 要设置的新方向
- 如果新方向和旧方向一致，结束
- 如果newDirection是stopped，抛出TypeError错误
- transceiver.Direction = newDirection
- 更新connection的negotiation-needed标识

currentDirection,是指当前协商方向。并且和RTCRtpEncodingParameters.active无关。
如果这个通道对象并没有重用(重新用在offer/answer交换中)，那这个值就为null。
如果通道状态是stopped，那么这个值也是stopped

currentDirection在获取方面的逻辑如下：

- 如果transceiver.Stopped是true，返回stopped，和上面说的一致
- 其他情况，返回内部状态CurrentDirection
